# Introduction

**üìå Objectifs d'un prototype de calcul HTML :**

- üí° Concr√©tiser une nouvelle id√©e
- üóÇÔ∏è Expliciter les besoins sous-jacents

**üõ† Usages concrets :**

- üé® Brainstorming / Co-construction
- ‚úçÔ∏è Sp√©cifications / Crit√®res d'acceptance
- üë• Tests utilisateurs (UI/UX)
- üñºÔ∏è D√©mos r√©alistes (UI/UX)

**üí° D√©marche IA**

1. üö≤ Minimalisme ‚Üí privil√©gier peu de logique m√©tier, donn√©es statiques  
2. üß© Simplification ‚Üí prototyper petit avec hypoth√®ses l√©g√®res  
3. üé§ Clarification ‚Üí demander √† GPT de poser des questions  
4. üí° Am√©lioration ‚Üí demander √† GPT des pistes d‚Äôoptimisation  
5. üì¶ Exhaustivit√© ‚Üí regrouper un max de demandes dans un message avant r√©g√©n√©ration  
6. üìê V√©rification ‚Üí g√©n√©rer un diagramme UML pour documenter  
7. üìù It√©ration ‚Üí amender le prompt jusqu‚Äô√† satisfaction  
8. üìå Transmission ‚Üí demander √† GPT de refournir le prompt final

**ü§ñ Lien √† la conversation IA**
```
https://chatgpt.com/share/68a33867-818c-8006-ac8c-efbd47c3d3ec
```

# Prompt

# 1) Contexte üåç
**‚ùì Cette section r√©pond √† :**
- √Ä quoi sert MAESTRO et pour qui ?
- Quelles r√®gles m√©tier guident la recommandation de centre ?
- Quelles simplifications ont √©t√© prises pour le prototype ?
- Quelles strat√©gies de recommandation sont compar√©es ?

## Objectif
MAESTRO est un outil de **gestion et d‚Äôallocation des demandes de maintenance moteur**. Le prototype vise √† **recommander le centre** le plus adapt√© pour une demande donn√©e et √† **visualiser la charge/capacit√©** des centres sur 3 mois, avec deux strat√©gies :
- **FastETA** : minimise le d√©lai total th√©orique (acheminement + ops + retour + attente basique).
- **ResponsibleETA** : ajoute une **p√©nalit√© de saturation** √† 4 semaines pour √©viter les centres fr√©quemment pleins (approche ‚Äúresponsable‚Äù).

## R√®gles m√©tier (pilotage de la reco)
- Compatibilit√© **Centre √ó (Moteur, Type)** requise.
- **Urgent** prioritaire (pas d‚Äôattente additionnelle si saturation imm√©diate ; Standard peut attendre la 1 ≥·µâ semaine si >100%).
- P√©nalit√© ResponsibleETA bas√©e sur le **taux d‚Äôoccupation pr√©vu** √† 4 semaines pour le **type** (ind√©pendant du moteur).
- **Bris d‚Äô√©galit√©** : l√©ger bruit (jitter ¬±0,5 j), puis **fiabilit√©** du centre.

## Simplifications retenues (pour le proto)
- **Acheminement** : tirage al√©atoire discret (0‚Äì4 jours) √† l‚Äôaller **et** au retour (pas de distance g√©o).
- **Dur√©es d‚Äôop√©rations** : d√©pendent **du type** uniquement (pas de variation par moteur/centre).
- **Aucun al√©a d‚Äôex√©cution** (maintenance d√©terministe hors randomisation initiale).
- **Arriv√©es des demandes** : lin√©aires (densit√© croissante √† l‚Äôapproche de la date d‚Äôop√©ration).

---

# 2) Donn√©es üìä
**‚ùì Cette section r√©pond √† :**
- Quels objets et attributs composent le mod√®le de donn√©es ?
- Quelles listes de r√©f√©rence (moteurs, types, centres) sont utilis√©es ?
- Comment sont g√©n√©r√©es les capacit√©s, charges et demandes existantes ?
- Quels param√®tres de randomisation contr√¥lent le jeu de donn√©es ?

## Mod√®le (objets principaux)
- **Centre** `{id, name, engines:Set, types:Set, capBase, trend, capByDay[], loadByDay[], loadByDayByType[type][]}`
- **Demande** `{id, client, centreName, engine, type, priority, startDate, duration}`
- **Param√®tres** `seed, weeks, clients, existing, pUrgent, capMin..capMax, trendMin..trendMax, durations[type]=[min,mode,max], shipW[0..4], reserveUrgPct, penaltyFactor`

## R√©f√©rentiels
- **Moteurs (5)** : `LEAP-1A, LEAP-1B, CFM56-5B, CFM56-7B, SaM146`
- **Types (4)** : `Overhaul, RepairOnly, QuickInspection, TestOnly`
- **Centres (20 villes)** : Paris, Lyon, Toulouse, Bordeaux, Nantes, Lille, Marseille, Nice, Strasbourg, Rennes, Grenoble, Montpellier, Clermont-F., Rouen, Tours, Dijon, Nancy, Orl√©ans, Metz, Reims
  - Chaque centre supporte **2‚Äì3 moteurs** et **2‚Äì3 types** (tirage uniforme sans doublon).

## Param√®tres & distributions (√©ditables dans ‚ÄúMaster Data‚Äù)
- **Seed** `42` ; **Horizon** `12 semaines` ; **Clients** `30` ; **Demandes existantes** `250` ; **%Urgent** `25%`.
- **Capacit√© de base (slots/jour)** : entier **U[4,10]**.
- **Facteur jour** : Lun‚ÄìJeu ~U[0.9,1.1] ; Ven ~U[0.8,1.0] ; Sam ~U[0.6,0.8] ; Dim ~U[0.4,0.6].
- **Tendance** (lin√©aire sur 12 sem.) : **U[-10%, +10%]**.
- **Dur√©es (jours, triangulaire [min, mode, max])**  
  | Type             | Tri[min, mode, max] |
  |------------------|----------------------|
  | TestOnly         | [2, 3, 4]            |
  | QuickInspection  | [3, 4, 6]            |
  | RepairOnly       | [12, 18, 28]         |
  | Overhaul         | [35, 45, 65]         |
- **Acheminement (jours)** : tirage {0,1,2,3,4} avec poids `{25,35,20,15,5}%`. Retour = aller.
- **Urgent r√©serv√©** (concept) : `reserveUrgPct = 25%` (utilis√© via la r√®gle ‚ÄúUrgent = pas d‚Äôattente basique‚Äù).
- **Facteur de p√©nalit√©** : `penaltyFactor = 1.0` (√©chelle de la p√©nalit√© ResponsibleETA).

## G√©n√©ration & calculs de charge
- **Capacit√©/jour** = `capBase √ó facteur_jour √ó drift(tendance)`.
- **Demandes existantes** : 250, avec **date de d√©but** tir√©e dans l‚Äôhorizon, **priorit√©** selon `%Urgent`.
- **Plottage** de la charge : pour chaque demande, **+1 slot/jour** pendant `dur√©e`.
- **Occupation_jour** = `loadByDay / capByDay`, born√©e √† 150%.
- **Heatmap (hebdo)** : **max**(Occupation_jour) de la semaine.
- **Approx. moteur** pour heatmap (ligne `type √ó moteur`) : la charge de `type` est r√©partie **√† parts √©gales** entre moteurs support√©s (hypoth√®se d‚Äôaffichage).

---

# 3) Interface üß©
**‚ùì Cette section r√©pond √† :**
- Quels onglets et actions l‚Äôinterface propose-t-elle ?
- Comment saisir une demande et consulter la recommandation ?
- Comment √©diter la donn√©e et rejouer le calcul ?
- Quelles vues d‚Äôanalyse (heatmap, listes filtr√©es) sont disponibles ?

## Structure Fiori-like (full width, responsive)
- **Topbar** : branding + **4 onglets**.
- **Cartes** (cards) avec ent√™tes, barres d‚Äôoutils et **tables** lisibles.
- **Composants** : s√©lecteurs, boutons (primaire/secondaire/ghost), grilles.

## Onglet 1 ‚Äî *Saisie & Reco*
- Formulaire : **Client**, **Moteur**, **Type**, **Priorit√©**, **Date de mise √† disposition**.
- Bouton **√âvaluer** ‚Üí calcule et affiche toutes les options **Centre** avec **FastETA**, **ResponsibleETA** et **d√©tail** (aller, ops, attente, retour, p√©nalit√©).
- Mise en avant de la **reco Fast** et **reco Responsible** (surbrillance).
- Bouton **Ajouter cette demande** ‚Üí inscrit la demande dans la **charge** (impacte heatmap & futures ETAs).

## Onglet 2 ‚Äî *Master Data & Randomization*
- Panneaux pour √©diter : **Seed**, **Horizon**, **Volumes**, **Capacit√© min/max**, **Tendance min/max**, **Dur√©es triangulaires**, **Poids d‚Äôacheminement**, **%Urgent**, **Facteur de p√©nalit√©**.
- Boutons : **Reg√©n√©rer la donn√©e**, **Export JSON**, **Import JSON**.
- Tableau **Compatibilit√©s** : Centre ‚Üí Moteurs/Types/Cap. base.

## Onglet 3 ‚Äî *Centres ‚Ä¢ Heatmap*
- S√©lecteur **Centre**.
- **Heatmap 12 semaines** : lignes = **(Type √ó Moteur)** compatibles, colonnes = semaines, cellule = **max d‚Äôoccupation** de la semaine.
- Infobulle survol : d√©tail de la semaine / %.

## Onglet 4 ‚Äî *Demandes ‚Ä¢ Liste*
- Filtres : **Centre**, **Moteur**, **Type**, **Priorit√©**, **P√©riode (date de d√©but)**.
- Tableau tri√© par date : `#`, `Client`, `Centre`, `Moteur`, `Type`, `Priorit√©`, `D√©but`, `Dur√©e`.

---

# 4) Technique üß†
**‚ùì Cette section r√©pond √† :**
- Quelles sont les formules d‚ÄôETA et les algorithmes de p√©nalit√©/attente ?
- Comment la randomisation est-elle impl√©ment√©e ?
- De quoi est compos√© le stack technique et comment est g√©r√©e la performance ?
- Quelles limites/approximations connues ?

## Stack & patterns
- **HTML/CSS/JS vanilla** (standalone, **sans d√©pendances externes**) ; style **Fiori-like**.
- **RNG d√©terministe** : `mulberry32(seed)`.
- **Distributions** :
  - **Triangulaire** pour les dur√©es (par type).
  - **Cat√©gorielle pond√©r√©e** pour l‚Äôacheminement (0‚Äì4 jours).
- **√âtat** en m√©moire (`Params`, `State`) ; **export/import JSON**.
- **Performance** : horizon 12√ó7 jours ; tableaux effil√©s ; pas de canvas/DOM lourd.

## Formules
- **Dur√©e moyenne par type** (pour p√©nalit√©) ‚âà `(min + mode + max) / 3`.
- **Attente basique (semaine 1)** :
  - `waitDays(Standard) = ceil(max(0, Occ_semaine1 - 1) √ó 7)`.
  - `waitDays(Urgent) = 0`.
- **P√©nalit√© Responsible (√† 4 semaines, par type)** :
  - `Occ‚ÇÑw = max_jour(semaine 4, loadType / cap)`
  - `excess = max(0, Occ‚ÇÑw - 1)`.
  - `penaltyDays = penaltyFactor √ó excess √ó avgDuration(type)`.
- **ETA** :
  - `FastETA = shipOut + duration(type) + waitDays + shipBack`.
  - `ResponsibleETA = FastETA + penaltyDays`.
  - **Jitter** (anti-√©galit√©) : ¬±0‚Äì0,5 j gaussien tronqu√© (arrondi final).
- **Compatibilit√©** : filtre **Centre √ó (Moteur, Type)**.
- **Placement de charge** (existing & ajout) : +1 **slot/jour** sur `duration` jours, √† partir de `startDate`.

## Limites / approximations (connues)
- **Dur√©es par type** uniquement (pas de granularit√© moteur/centre).
- **Approx. moteur heatmap** : partage √©gal de la charge du type entre moteurs support√©s.
- **Urgent** : pas de file d‚Äôattente fine ni capacit√© r√©serv√©e ‚Äúdure‚Äù (r√®gle simple = pas d‚Äôattente basique).
- **Acheminement** : pas de g√©oloc ; tirage discret.
- **Saisies** : pas de validation complexe (focus sur l‚Äôexploration).

## Extensions possibles (2‚Äì3 pistes)
- Introduire **dur√©es par (Type √ó Moteur)** et **facteur centre**.
- R√©server **capacit√© dure** aux urgents par centre (ex. 20‚Äì30%).
- Ajouter **Top-3** centres avec **score multi-crit√®res** (ETA, saturation, distance proxy).
