# Introduction

**üìå Objectifs d'un prototype fonctionnelle HTML :**

- üí° Transformer une id√©e en une feature
- üóÇÔ∏è Stabiliser les besoins autour de la feature en vue du d√©veloppement

**üõ† Usages concrets :**

- üé® Brainstorming / Co-construction
- ‚úçÔ∏è Sp√©cifications / Crit√®res d'acceptance
- üë• Tests utilisateurs (UI/UX)
- üñºÔ∏è D√©mos r√©alistes (UI/UX)

**üí° D√©marche IA**

1. üö≤ Minimalisme ‚Üí privil√©gier peu de logique m√©tier, donn√©es statiques  
2. üß© Simplification ‚Üí prototyper petit avec hypoth√®ses l√©g√®res  
3. üé§ Clarification ‚Üí demander √† GPT de poser des questions  
4. üí° Am√©lioration ‚Üí demander √† GPT des pistes d‚Äôoptimisation  
5. üì¶ Exhaustivit√© ‚Üí regrouper un max de demandes dans un message avant r√©g√©n√©ration  
6. üìê V√©rification ‚Üí g√©n√©rer un diagramme UML pour documenter  
7. üìù It√©ration ‚Üí amender le prompt jusqu‚Äô√† satisfaction  
8. üìå Transmission ‚Üí demander √† GPT de refournir le prompt final

**ü§ñ Lien √† la conversation IA**
```
https://chatgpt.com/share/68a33867-818c-8006-ac8c-efbd47c3d3ec
```
> [!NOTE] 
> L'exemple montr√© n'est pas √† suivre. Il comporte des it√©rations de code existant qui √©chouent. Cela montre bien l'importance de regrouper les demandes dans un un message pour g√©n√©rer le nouveau code. Pour r√©soudre le probl√®me, il est n√©cessaire de demander la r√©g√©n√©ration complet du prototype m√™me pour des am√©lioration mineurs. 

# Prompt

<img width="1919" height="891" alt="image" src="https://github.com/user-attachments/assets/3f8390b4-a6b9-42b9-98c8-75f0255b3de8" />
<img width="1905" height="955" alt="image" src="https://github.com/user-attachments/assets/2652ae92-d215-4df9-869f-67ad48bf6919" />
<img width="1917" height="746" alt="image" src="https://github.com/user-attachments/assets/cccadec9-d5c2-4814-999e-e74977584c68" />

## 1. Contexte  
**‚ùìQuel probl√®me on r√©sout ? Pour qui ? Avec quels compromis ?**  
- But : recommander le **centre de maintenance** le plus adapt√© pour une demande (Client, Moteur, Type, Priorit√©), avec 2 strat√©gies : **‚ö° FastETA** (le plus court) et **üçÄ ResponsibleETA** (le plus s√ªr vs saturation).  
- Utilisateurs : planificateurs / coordinateurs MRO qui veulent **voir, simuler, affecter** vite.  
- Compromis (prototype) : **r√©aliste mais l√©ger** ‚Üí acheminement **fixe** (client√ócentre), dur√©e **fixe** (type√ómoteur), **pas** de g√©odistance, **pas** d‚Äôal√©as.  
- D√©terminisme : √† param√®tres identiques (y c. **date de dispo**), l‚ÄôETA **ne varie pas**.

---

## 2. Donn√©es  
**‚ùìDe quelles donn√©es ai-je besoin ? Qu‚Äôest-ce qui est fixe vs al√©atoire ? Comment initialiser vite ?**  
- **TE = Type √ó Engine (couple ‚Äútype de demande √ó moteur‚Äù)**. C‚Äôest l‚Äôunit√© de charge/capacit√© pour mesurer la saturation fine.  
- **R√©f√©rentiels**  
  - **Centres** (20 villes FR). Chaque centre g√®re **2‚Äì3 moteurs** parmi `LEAP-1A, LEAP-1B, CFM56-5B, CFM56-7B, SaM146` et **2‚Äì3 types** parmi `Overhaul, RepairOnly, QuickInspection, TestOnly`.  
  - **Clients** : ex. 30 (`Client-001`‚Ä¶`Client-030`).  
- **Param√®tres ‚Äúfix√©s une fois‚Äù (tir√©s au setup, puis gel√©s)**  
  - **Acheminement** (jours) **client√ócentre** : entier 0‚Äì4 selon une **loi discr√®te** (poids configurables). **Aller = retour.**  
  - **Dur√©e d‚Äôop√©ration** (jours) **TE (type√ómoteur)** : **triangulaire** *(min, mode, max)* ‚Üí valeur enti√®re, **puis gel√©e**.  
- **Capacit√© & charge**  
  - **Capacit√©/jour par centre** = base (4‚Äì10) √ó facteur ‚Äújour de semaine‚Äù √ó **tendance** lin√©aire (-10% √† +10%).  
  - **TE-light** : on alloue la capacit√© du centre aux TE **via quotas uniformes** (1 / #TE compatibles).  
  - **Charges existantes** : N demandes (ex. 250, ~25% urgentes) r√©parties sur **12 semaines**.  
- **Occupation**  
  - **OccTE(jour)** = `loadTE / capTE`. **OccTE(semaine)** = **max** des 7 jours.

```mermaid
%% UML ‚Äî Vue "Donn√©es & R√®gles" (TE-light)
classDiagram
  direction LR

  class Customer {
    +id: String
    +name: String
  }

  class Engine {
    <<enumeration>>
    +LEAP-1A
    +LEAP-1B
    +CFM56-5B
    +CFM56-7B
    +SaM146
  }

  class RequestType {
    <<enumeration>>
    +Overhaul
    +RepairOnly
    +QuickInspection
    +TestOnly
  }

  class Priority {
    <<enumeration>>
    +Urgent
    +Standard
  }

  class TE {
    +type: RequestType
    +engine: Engine
    +key(): String
  }
  %% TE = Type √ó Engine (le couple "type de demande √ó moteur")
  %% Capacit√©/charge sont mesur√©es et pilot√©es √† ce grain.

  class Centre {
    +name: String
    +engines: Set<Engine>
    +types: Set<RequestType>
    +capByDay: int[]
    +quotaTE: Map<TE, float>
    +loadByDay: int[]
    +loadByDayByType: Map<RequestType, int[]>
    +loadByDayByTE: Map<TE, int[]>
    +supports(e:Engine,t:RequestType): bool
  }

  class ShipMatrix {
    +shipDays: Map<Customer, Map<Centre,int>>
    +getDays(cust:Customer, centre:Centre): int
  }

  class OpDurTable {
    +dur: Map<RequestType, Map<Engine,int>>
    +getDays(type:RequestType, engine:Engine): int
  }

  class Request {
    +client: Customer
    +engine: Engine
    +type: RequestType
    +priority: Priority
    +available: Date
  }

  class EvalRow {
    +centre: Centre
    +fast: int           %% ‚ö° FastETA (jours)
    +responsible: int    %% üçÄ ResponsibleETA (jours)
    +shipOut: int
    +shipBack: int
    +dur: int
    +wait: int
    +penalty: int
  }

  class EvalResult {
    +rows: EvalRow[]
    +bestFast: EvalRow
    +bestResponsible: EvalRow
  }

  class Evaluator {
    +evaluate(req:Request): EvalResult
    +capTE(c:Centre, te:TE, day:int): int
    +occWeekTE(c:Centre, te:TE, weekStart:int): float
    +waitDays(c:Centre, te:TE, prio:Priority, anchor:int): int
    +penaltyDays(c:Centre, te:TE, anchor:int): int
  }

  class Calendar {
    +place(d:Demand): void
  }

  class Demand {
    +id: String
    +client: Customer
    +centre: Centre
    +engine: Engine
    +type: RequestType
    +priority: Priority
    +startDate: Date
    +duration: int
  }

  %% Relations
  Request --> Customer
  Request --> Engine
  Request --> RequestType
  Request --> Priority
  Demand --> Centre
  Demand --> Customer
  Demand --> Engine
  Demand --> RequestType

  Evaluator --> ShipMatrix : utilise (shipAller/Retour)
  Evaluator --> OpDurTable : utilise (dur(TE))
  Evaluator --> Centre : filtre √©ligibles & lit cap/charges
  Calendar --> Centre : met √† jour loadByDay / loadByDayByTE

  %% R√®gles TE-light (notes)
  note for Evaluator "FastETA = shipOut + dur(TE) + shipBack + Wait\nResponsibleETA = FastETA + Penalty"
  note for Centre "capTE = round(capCentre * quotaTE)\nquotaTE: uniforme par d√©faut"
  note "Simplification priorisation : Urgent pr√©emptif doux ‚áí Wait(Urgent)=0 ; Standard absorbe l'attente via OccTE(sem0)" as Nprio
  Nprio .. Priority


```

```mermaid
%% UML ‚Äî Vue "Flux d'√©valuation & affectation"
sequenceDiagram
  autonumber
  actor U as Utilisateur
  participant UI as Interface (onglet Demande & Reco)
  participant Eval as Evaluator
  participant SM as ShipMatrix
  participant OD as OpDurTable
  participant C as Centres[*]
  participant Cal as Calendar (planning)

  U->>UI: Saisit Client, Moteur, Type, Priorit√©, Date dispo
  UI->>Eval: evaluate(Request)

  Eval->>C: Filtre centres √©ligibles (supports(type, moteur))
  loop Pour chaque centre √©ligible
    Eval->>SM: getDays(client, centre)
    SM-->>Eval: shipOut/shipBack (fixes)

    Eval->>OD: getDays(type, engine)
    OD-->>Eval: dur(TE) (fixe)

    Eval->>C: occWeekTE(centre, TE, semaine 0 & semaine 4)
    C-->>Eval: max OccTE_sem0 / OccTE_sem4

    Eval-->>UI: calcule Wait(priorit√©, sem0) et Penalty(sem4)
    Note over Eval: Urgent ‚ûú Wait=0\nStandard ‚ûú Wait = ceil(max(OccTE_sem0-1)*7)
  end

  Eval-->>UI: EvalResult (rows tri√©es par üçÄ ResponsibleETA,\nmeilleur ‚ö° et meilleur üçÄ identifi√©s)
  UI-->>U: Affiche tableau (surlignages vert/jaune/rouge) + heatmap

  alt Ajout au planning
    U->>UI: Clique "Ajouter au planning"
    UI->>Cal: place(Demand) sur le centre recommand√©
    Cal->>C: Met √† jour charges (loadByDay, loadByDayByTE)
    UI-->>U: Heatmap rafra√Æchie (occupations TE √† jour)
  end

```

## 3. Interface  
**‚ùìQuelles actions ? Comment lire la reco ? Quelles vues ?**  
1) **üì• Demande & Reco**  
   - Form : **Client, Moteur, Type, Priorit√©, Date de mise √† dispo**.  
   - Tableau tri√© par **üçÄ ResponsibleETA**. Surlignage : **vert** = meilleur üçÄ, **jaune** = meilleur ‚ö° ; **rouge** si *Attente* ou *P√©nalit√©* > 0.  
   - **Ajouter au planning** ‚Üí met √† jour la charge.  
   - **Heatmap TE** (ind√©pendante) : lignes = **TE**, colonnes = **semaines** (en-t√™te = **1er jour** au format **DD/MM/YYYY**), cellule = **max OccTE** hebdo.  
2) **üß© Master Data**  
   - Seed, horizon, volumes, plages **triangulaires** des dur√©es, **poids d‚Äôacheminement**, **facteur de p√©nalit√©**.  
   - **Export/Import JSON** + tableau compatibilit√©s (centre ‚Üî moteurs/types).  
3) **üìÑ Demandes**  
   - Liste filtrable (**centre, moteur, type, priorit√©, date**), tri par date.



## 4. Technique  
**‚ùìQuelles r√®gles de calcul ? Qu‚Äôest-ce que TE-light ? Quelles garanties ?**  
- **Capacit√© TE-light** :  
  `capTE(c, TE, jour) = round( capCentre(c, jour) √ó quotaTE(c, TE) )` avec **quotaTE uniforme** (r√©glable plus tard).  
- **Fen√™tres temporelles** (ancr√©es sur la **Date de mise √† dispo** choisie) :  
  - **Semaine d‚Äôattente** = **semaine 0** (la semaine de la dispo).  
  - **Semaine de p√©nalit√©** = **semaine 4** (anticipation de saturation).  
- **Formules ETA**  
  - `FastETA = shipAller + dur(TE) + shipRetour + Wait`  
  - `Wait(Standard) = max(0, ceil( (maxOccTE_sem0 ‚àí 1) √ó 7 ))` ; `Wait(Urgent) = 0`  
  - `ResponsibleETA = FastETA + Penalty`  
  - `Penalty = max(0, maxOccTE_sem4 ‚àí 1) √ó AvgDur(type) √ó penaltyFactor`  
  - `AvgDur(type) = (min + mode + max) / 3` (les bornes viennent des dur√©es triangulaires du type).  
- **Hypoth√®se de simplification sur la priorisation**  
  - **Urgent** est **pr√©emptif ‚Äúdoux‚Äù** : on suppose que le centre peut **d√©caler des Standard** pour ins√©rer l‚ÄôUrgent ‚áí **Wait(Urgent)=0**, m√™me si la semaine 0 est pleine.  
  - Les **Standard** absorbent l‚Äôattente (en jours) selon **l‚Äôoccupation TE** de la semaine 0.  
  - Pas de micro-ordonnancement intra-jour, pas d‚Äôal√©as, pas de retard d‚Äôacheminement/maintenance.  
- **Garanties**  
  - Compatibilit√© stricte (**centre supporte type & moteur**).  
  - **Priorit√©** : `ETA(Urgent) ‚â§ ETA(Standard)` pour une m√™me demande.  
  - **D√©terminisme** : √† param√®tres identiques (y c. **date**), r√©sultats stables.

---

### Prochaines questions (pour adapter √† ton contexte)
- Souhaites-tu **√©diter les quotas TE** par centre (au lieu d‚Äôuniformes) ?  
- On rend **configurable** la ‚Äúsemaine de p√©nalit√©‚Äù (S+3/S+4/S+5) ?  
- On ajoute une vue **comparative** Standard ‚Üî Urgent (avant/apr√®s) dans l‚Äôonglet 1 ?
